import streamlit as st
import os
import sys
import traceback
import tempfile
import json
from datetime import datetime
import uuid
import warnings
import io
import time
from pathlib import Path
import pandas as pd
from io import BytesIO
import re

# Importaciones para audio
try:
    import whisper
    WHISPER_AVAILABLE = True
except ImportError as e:
    WHISPER_AVAILABLE = False

try:
    from pydub import AudioSegment
    PYDUB_AVAILABLE = True
except ImportError as e:
    PYDUB_AVAILABLE = False

# Configuraci√≥n de la p√°gina
st.set_page_config(
    page_title="Sistema de An√°lisis de Performance",
    page_icon="üéôÔ∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Verificar compatibilidad de Python
python_version = sys.version_info

def check_ffmpeg_available():
    """Verificar si FFmpeg est√° disponible silenciosamente"""
    try:
        import subprocess
        result = subprocess.run(['ffmpeg', '-version'], 
                              capture_output=True, 
                              text=True, 
                              timeout=5)
        return result.returncode == 0
    except:
        return False

def check_audio_format(filename):
    """Verificar formato de audio y dar recomendaciones"""
    ext = filename.lower().split('.')[-1]
    
    format_info = {
        'wav': {'compatible': True, 'note': 'Formato √≥ptimo - Compatible al 100%'},
        'mp3': {'compatible': True, 'note': 'Buena compatibilidad - Requiere FFmpeg para conversi√≥n'},
        'mp4': {'compatible': True, 'note': 'Buena compatibilidad - Requiere FFmpeg'},
        'm4a': {'compatible': True, 'note': 'Buena compatibilidad - Requiere FFmpeg'},
        'flac': {'compatible': True, 'note': 'Alta calidad - Requiere FFmpeg'},
        'ogg': {'compatible': True, 'note': 'Buena compatibilidad - Requiere FFmpeg'},
        'webm': {'compatible': False, 'note': 'Formato complejo - Convertir a WAV recomendado'},
        'avi': {'compatible': False, 'note': 'Formato de video - Extraer audio primero'}
    }
    
    return format_info.get(ext, {'compatible': False, 'note': 'Formato no reconocido - Usar WAV'})

# Configuraciones y funciones auxiliares
UPLOAD_FOLDER = 'uploads'
ALLOWED_EXTENSIONS = {'wav', 'mp3', 'mp4', 'avi', 'mov', 'flac', 'm4a', 'ogg', 'webm'}

# Crear directorios si no existen
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

def allowed_file(filename):
    """Verificar si el archivo tiene una extensi√≥n permitida"""
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def load_whisper_model_no_cache():
    """Cargar modelo Whisper sin cache para debugging"""
    if not WHISPER_AVAILABLE:
        return None
    
    try:
        import whisper
        # Intentar modelos de menor a mayor
        models_to_try = ["tiny", "base", "small"]
        
        for model_name in models_to_try:
            try:
                st.info(f"Intentando cargar modelo '{model_name}'...")
                model = whisper.load_model(model_name)
                st.success(f"‚úÖ Modelo '{model_name}' cargado exitosamente")
                return model
            except Exception as e:
                st.warning(f"‚ö†Ô∏è Modelo '{model_name}' fall√≥: {str(e)}")
                continue
        
        return None
    except Exception as e:
        st.error(f"Error cr√≠tico: {str(e)}")
        return None

@st.cache_resource
def load_whisper_model():
    """Cargar modelo Whisper con cache y manejo robusto de errores"""
    if not WHISPER_AVAILABLE:
        return None
    
    try:
        with st.spinner("üîÑ Cargando modelo Whisper (puede tomar unos momentos la primera vez)..."):
            # Usar modelo tiny para pruebas r√°pidas, base para producci√≥n
            model = whisper.load_model("tiny")  # Cambiar a "base" para mejor calidad
            return model
    except Exception as e:
        st.error(f"Error espec√≠fico cargando Whisper: {str(e)}")
        
        # Intentar con modelo m√°s peque√±o
        try:
            st.info("Intentando con modelo m√°s ligero...")
            model = whisper.load_model("tiny")
            st.success("‚úÖ Modelo ligero cargado exitosamente")
            return model
        except Exception as e2:
            st.error(f"Error cr√≠tico: {str(e2)}")
            
            # Diagn√≥stico adicional
            st.warning("üîç **Diagn√≥stico del problema:**")
            st.markdown("‚Ä¢ Problema de conectividad para descargar modelo")
            st.markdown("‚Ä¢ Espacio insuficiente en disco")
            st.markdown("‚Ä¢ Permisos de escritura en el directorio")
            
            return None

def convert_audio_to_wav(file_path):
    """Convertir audio a WAV si es necesario"""
    # Verificar si ya es WAV
    if file_path.lower().endswith('.wav'):
        return file_path
    
    if not PYDUB_AVAILABLE:
        st.warning("‚ö†Ô∏è Conversi√≥n de audio no disponible. Sube un archivo WAV directamente.")
        return file_path
    
    try:
        # Intentar conversi√≥n con pydub
        audio = AudioSegment.from_file(file_path)
        wav_path = file_path.replace(os.path.splitext(file_path)[1], '.wav')
        audio.export(wav_path, format="wav")
        return wav_path
    except Exception as e:
        st.info(f"üí° No se pudo convertir el audio autom√°ticamente. Usa archivos WAV para mejores resultados.")
        # Intentar usar el archivo original directamente con Whisper
        return file_path

def transcribe_audio(model, file_path):
    """Transcribir audio con Whisper - versi√≥n robusta"""
    if not model:
        return None, "Modelo Whisper no disponible"
    
    try:
        # Whisper puede manejar muchos formatos sin conversi√≥n
        # Usar fp16=False para compatibilidad con CPU
        result = model.transcribe(
            file_path, 
            language="es", 
            fp16=False,
            verbose=False
        )
        return result, None
    except FileNotFoundError as e:
        if "ffmpeg" in str(e).lower() or "ffprobe" in str(e).lower():
            return None, "FFmpeg no est√° instalado. Usar archivos WAV o instalar FFmpeg."
        return None, f"Archivo no encontrado: {str(e)}"
    except Exception as e:
        error_msg = str(e)
        
        # Manejo espec√≠fico de errores comunes
        if "ffmpeg" in error_msg.lower():
            return None, "Error: FFmpeg requerido para este formato. Usar archivos WAV."
        elif "decode" in error_msg.lower():
            return None, "Error: Formato de audio no soportado. Usar WAV, MP3 o M4A."
        elif "permission" in error_msg.lower():
            return None, "Error: Sin permisos para acceder al archivo."
        else:
            return None, f"Error de transcripci√≥n: {error_msg}"

def format_dialogue(segments):
    """Formatear segmentos como di√°logo"""
    dialogue = []
    current_speaker = 1
    last_end = 0
    
    for i, segment in enumerate(segments):
        start = segment['start']
        text = segment['text'].strip()
        
        # Simple detecci√≥n de cambio de speaker basada en pausas
        if start - last_end > 2.0:  # Pausa de m√°s de 2 segundos
            current_speaker = 2 if current_speaker == 1 else 1
        
        speaker_name = "ASESOR" if current_speaker == 1 else "CLIENTE"
        timestamp = f"{int(start//60):02d}:{int(start%60):02d}"
        
        dialogue.append({
            'timestamp': timestamp,
            'speaker': speaker_name,
            'text': text
        })
        
        last_end = segment['end']
    
    return dialogue

def analyze_performance(text):
    """An√°lisis completo de performance del asesor"""
    text_lower = text.lower()
    
    # An√°lisis de protocolo
    protocol_analysis = {
        "saludo_inicial": any(saludo in text_lower for saludo in [
            "hola", "buenos d√≠as", "buenas tardes", "buenas noches", 
            "bienvenido", "gracias por contactar", "habla con"
        ]),
        "identificacion": any(id_phrase in text_lower for id_phrase in [
            "su nombre", "me puede dar", "necesito sus datos", "podr√≠a confirmar",
            "su n√∫mero de documento", "su dni", "su identificaci√≥n"
        ]),
        "pregunta_ayuda": any(ayuda in text_lower for ayuda in [
            "en qu√© puedo ayudar", "c√≥mo puedo ayudar", "cu√°l es su consulta",
            "qu√© necesita", "en qu√© le puedo asistir", "motivo de su llamada"
        ]),
        "despedida": any(despedida in text_lower for despedida in [
            "que tenga buen d√≠a", "gracias por contactar", "hasta luego",
            "que est√© bien", "nos vemos", "chau", "adi√≥s"
        ])
    }
    
    protocol_score = (sum(protocol_analysis.values()) / len(protocol_analysis)) * 100
    
    # An√°lisis de tono
    tono_positivo = sum([text_lower.count(x) for x in ['por favor', 'con gusto', 'perfecto', 'excelente']])
    tono_negativo = sum([text_lower.count(x) for x in ['no puede', 'imposible', 'no funciona']])
    
    if tono_positivo + tono_negativo > 0:
        tono_score = (tono_positivo / (tono_positivo + tono_negativo)) * 100
    else:
        tono_score = 50
    
    return {
        'protocol_analysis': protocol_analysis,
        'protocol_score': protocol_score,
        'tone_score': tono_score,
        'overall_score': (protocol_score + tono_score) / 2
    }

def generate_ai_prompt(dialogue, analysis, transcription):
    """Generar prompt optimizado para IA"""
    dialogue_text = "\n".join([
        f"[{item['timestamp']}] {item['speaker']}: {item['text']}"
        for item in dialogue
    ])
    
    prompt = f"""üéØ AN√ÅLISIS DE LLAMADA DE ATENCI√ìN AL CLIENTE

üìä SCORES AUTOM√ÅTICOS:
‚Ä¢ Protocolo: {analysis['protocol_score']:.1f}%
‚Ä¢ Tono: {analysis['tone_score']:.1f}%
‚Ä¢ General: {analysis['overall_score']:.1f}%

üìã PROTOCOLO EVALUADO:
‚Ä¢ Saludo inicial: {'‚úì S√ç' if analysis['protocol_analysis']['saludo_inicial'] else '‚úó NO'}
‚Ä¢ Identificaci√≥n: {'‚úì S√ç' if analysis['protocol_analysis']['identificacion'] else '‚úó NO'}
‚Ä¢ Pregunta de ayuda: {'‚úì S√ç' if analysis['protocol_analysis']['pregunta_ayuda'] else '‚úó NO'}
‚Ä¢ Despedida: {'‚úì S√ç' if analysis['protocol_analysis']['despedida'] else '‚úó NO'}

üí¨ DI√ÅLOGO POR INTERLOCUTORES:
{dialogue_text}

üìù TRANSCRIPCI√ìN COMPLETA:
"{transcription}"

ü§ñ SOLICITUD PARA IA:
Por favor analiza esta llamada de atenci√≥n al cliente y proporciona:

1. An√°lisis detallado del desempe√±o del asesor
2. Recomendaciones espec√≠ficas para mejorar la atenci√≥n
3. Evaluaci√≥n de la satisfacci√≥n del cliente
4. Sugerencias de entrenamiento o coaching
5. Puntos positivos que el asesor deber√≠a mantener
6. Calificaci√≥n general del 1-10 con justificaci√≥n
7. An√°lisis de las din√°micas de conversaci√≥n
8. Evaluaci√≥n del equilibrio en la participaci√≥n

Contexto: An√°lisis de calidad de servicio al cliente para mejorar la atenci√≥n.
"""
    return prompt

# APLICACI√ìN PRINCIPAL
st.title("üéôÔ∏è Sistema de An√°lisis de Performance")
st.markdown("### üìä An√°lisis Profesional de Atenci√≥n al Cliente")

# Tabs principales
tab1, tab2, tab3 = st.tabs(["üìÅ Subir Audio", "üìù An√°lisis Manual", "üìä Resultados"])

with tab1:
    st.header("üìÅ Dashboard de Subida de Audio")
    
    # Verificar estado de las dependencias
    ffmpeg_status = check_ffmpeg_available()
    
    if not ffmpeg_status:
        st.info("üí° **Estado del sistema:** FFmpeg no detectado. Archivos WAV funcionar√°n perfectamente.")
    
    # Bot√≥n de diagn√≥stico
    if st.button("üîç Ejecutar Diagn√≥stico del Sistema"):
        with st.expander("üìã Resultados del Diagn√≥stico", expanded=True):
            # Verificar Whisper
            if WHISPER_AVAILABLE:
                st.success("‚úÖ Whisper disponible")
                try:
                    import whisper
                    st.write(f"   Versi√≥n: {whisper.__version__}")
                    
                    # Intentar cargar modelo
                    try:
                        with st.spinner("Probando carga de modelo..."):
                            test_model = whisper.load_model("tiny")
                        st.success("‚úÖ Modelo Whisper carga correctamente")
                    except Exception as e:
                        st.error(f"‚ùå Error cargando modelo: {e}")
                except Exception as e:
                    st.error(f"‚ùå Error con Whisper: {e}")
            else:
                st.error("‚ùå Whisper no disponible")
            
            # Verificar FFmpeg
            if ffmpeg_status:
                st.success("‚úÖ FFmpeg disponible")
            else:
                st.warning("‚ö†Ô∏è FFmpeg no disponible")
            
            # Verificar Pydub
            if PYDUB_AVAILABLE:
                st.success("‚úÖ Pydub disponible")
            else:
                st.warning("‚ö†Ô∏è Pydub no disponible")
            
            # Informaci√≥n del sistema
            import sys
            st.info(f"üêç Python: {sys.version}")
            
            # Verificar espacio en disco
            import shutil
            free_space = shutil.disk_usage('.').free / (1024**3)
            st.info(f"üíæ Espacio libre: {free_space:.1f} GB")
            
            if free_space < 1:
                st.warning("‚ö†Ô∏è Poco espacio en disco - puede afectar descarga de modelos")
            
            # Bot√≥n para limpiar cache
            if st.button("üßπ Limpiar Cache de Streamlit"):
                st.cache_resource.clear()
                st.success("‚úÖ Cache limpiada - recarga la p√°gina")
    
    uploaded_file = st.file_uploader(
        "Selecciona un archivo de audio:",
        type=['wav', 'mp3', 'mp4', 'avi', 'mov', 'flac', 'm4a', 'ogg', 'webm'],
        help="Formatos soportados: WAV, MP3, MP4, AVI, MOV, FLAC, M4A, OGG, WEBM"
    )
    
    if uploaded_file is not None:
        # Verificar formato de archivo
        format_info = check_audio_format(uploaded_file.name)
        
        # Mostrar informaci√≥n del archivo
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("üìÑ Nombre", uploaded_file.name)
        with col2:
            st.metric("üìè Tama√±o", f"{uploaded_file.size / 1024 / 1024:.2f} MB")
        with col3:
            st.metric("üìã Tipo", uploaded_file.type)
        
        # Mostrar compatibilidad del formato
        if format_info['compatible']:
            st.success(f"‚úÖ **Formato compatible:** {format_info['note']}")
        else:
            st.warning(f"‚ö†Ô∏è **Formato problem√°tico:** {format_info['note']}")
            st.info("üí° **Recomendaci√≥n:** Convierte el archivo a WAV para mejor compatibilidad")
        
        # Guardar archivo temporalmente
        with tempfile.NamedTemporaryFile(delete=False, suffix=f".{uploaded_file.name.split('.')[-1]}") as tmp_file:
            tmp_file.write(uploaded_file.getvalue())
            temp_path = tmp_file.name
        
        st.success("‚úÖ Archivo subido correctamente")
        
        # Procesar transcripci√≥n
        if WHISPER_AVAILABLE:
            # Bot√≥n inteligente seg√∫n el formato
            if uploaded_file.name.lower().endswith('.wav'):
                button_text = "üéôÔ∏è Transcribir Audio WAV (Recomendado)"
                button_type = "primary"
            else:
                button_text = "üéôÔ∏è Intentar Transcripci√≥n (Puede requerir FFmpeg)"
                button_type = "secondary"
                
            if st.button(button_text, type=button_type):
                with st.spinner("üîÑ Procesando audio... Esto puede tomar unos minutos"):
                    # Cargar modelo
                    model = load_whisper_model()
                    
                    # Si falla con cache, intentar sin cache
                    if not model:
                        st.info("üîÑ Intentando carga alternativa sin cache...")
                        model = load_whisper_model_no_cache()
                    
                    if model:
                        # Intentar transcripci√≥n directa
                        result, error = transcribe_audio(model, temp_path)
                        
                        if result and not error:
                            st.session_state['transcription_result'] = result
                            st.session_state['audio_file'] = uploaded_file.name
                            st.success("‚úÖ Transcripci√≥n completada exitosamente")
                            st.rerun()
                        else:
                            st.error(f"‚ùå {error}")
                            
                            # Mostrar soluciones espec√≠ficas seg√∫n el error
                            if "FFmpeg" in error:
                                st.info("üîß **Soluciones para FFmpeg:**")
                                col1, col2 = st.columns(2)
                                with col1:
                                    st.markdown("**Opci√≥n 1: Instalar FFmpeg**")
                                    st.code("winget install ffmpeg")
                                    st.markdown("Luego reinicia VS Code")
                                with col2:
                                    st.markdown("**Opci√≥n 2: Usar WAV**")
                                    st.markdown("Convierte tu archivo a WAV:")
                                    st.markdown("‚Ä¢ [Online-Convert.com](https://audio.online-convert.com/es/convertir-a-wav)")
                                    st.markdown("‚Ä¢ [CloudConvert.com](https://cloudconvert.com/mp3-to-wav)")
                            
                            elif "formato" in error.lower():
                                st.info("üìÑ **Soluci√≥n de formato:**")
                                st.markdown("‚Ä¢ Convierte el archivo a **WAV** o **MP3**")
                                st.markdown("‚Ä¢ Usa herramientas como Audacity o convertidores online")
                            
                            st.markdown("**üí° Mientras tanto, puedes usar el an√°lisis manual en la siguiente pesta√±a**")
                    else:
                        st.error("‚ùå No se pudo cargar el modelo Whisper")
                        st.info("üîÑ Reinicia la aplicaci√≥n si el problema persiste")
        else:
            st.info("üí° **Transcripci√≥n autom√°tica disponible**")
            st.markdown("**Notas importantes:**")
            st.markdown("‚Ä¢ Whisper puede procesar la mayor√≠a de formatos de audio directamente")
            st.markdown("‚Ä¢ Para mejor compatibilidad, usa archivos WAV")
            st.markdown("‚Ä¢ Si hay errores, instala FFmpeg: `winget install ffmpeg`")
            st.markdown("‚Ä¢ **Formatos soportados:** MP3, WAV, MP4, M4A, FLAC, OGG")
            
            if st.button("üéôÔ∏è Transcribir Audio Directamente", type="primary"):
                with st.spinner("üîÑ Procesando audio... Esto puede tomar unos minutos"):
                    # Cargar modelo
                    model = load_whisper_model()
                    
                    if model:
                        # Intentar transcripci√≥n directa (Whisper maneja muchos formatos)
                        result, error = transcribe_audio(model, temp_path)
                        
                        if result and not error:
                            st.session_state['transcription_result'] = result
                            st.session_state['audio_file'] = uploaded_file.name
                            st.success("‚úÖ Transcripci√≥n completada")
                            st.rerun()
                        else:
                            st.error(f"‚ùå {error}")
                            st.info("üí° **Soluciones:**")
                            st.markdown("1. Instala FFmpeg: `winget install ffmpeg`")
                            st.markdown("2. Convierte tu audio a WAV usando un convertidor online")
                            st.markdown("3. Usa el an√°lisis manual con texto transcrito")
                    else:
                        st.error("‚ùå No se pudo cargar el modelo Whisper")

with tab2:
    st.header("üìù An√°lisis Manual de Texto")
    
    manual_text = st.text_area(
        "Ingresa el texto transcrito manualmente:",
        height=300,
        placeholder="Ejemplo: Hola, buenos d√≠as, habla con Mar√≠a del departamento de atenci√≥n al cliente, en qu√© puedo ayudarle..."
    )
    
    if manual_text and st.button("üîç Analizar Texto Manual"):
        # Crear resultado manual
        fake_segments = [{"start": 0, "end": len(manual_text)/10, "text": manual_text}]
        result = {
            "text": manual_text,
            "segments": fake_segments
        }
        st.session_state['transcription_result'] = result
        st.session_state['audio_file'] = "Texto Manual"
        st.success("‚úÖ Texto procesado para an√°lisis")
        st.rerun()

with tab3:
    st.header("üìä Resultados del An√°lisis")
    
    if 'transcription_result' in st.session_state:
        result = st.session_state['transcription_result']
        filename = st.session_state.get('audio_file', 'Audio')
        
        st.info(f"üìÅ **Archivo procesado:** {filename}")
        
        # Extraer texto y segmentos
        transcription = result['text']
        segments = result.get('segments', [])
        
        # Formatear como di√°logo
        dialogue = format_dialogue(segments)
        
        # An√°lisis de performance
        analysis = analyze_performance(transcription)
        
        # Mostrar m√©tricas
        st.subheader("üìä M√©tricas de Performance")
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("üìã Protocolo", f"{analysis['protocol_score']:.1f}%")
        with col2:
            st.metric("üé≠ Tono", f"{analysis['tone_score']:.1f}%")
        with col3:
            st.metric("üéØ General", f"{analysis['overall_score']:.1f}%")
        with col4:
            st.metric("üìù Palabras", len(transcription.split()))
        
        # Mostrar di√°logo formateado
        st.subheader("üí¨ Di√°logo por Interlocutores")
        
        # Crear visualizaci√≥n tipo chat
        for item in dialogue:
            if "ASESOR" in item['speaker']:
                st.markdown(f"""
                <div style='background-color: #e3f2fd; padding: 10px; border-radius: 10px; margin: 5px 0; border-left: 4px solid #2196f3;'>
                    <strong>üéß {item['speaker']} [{item['timestamp']}]:</strong><br>
                    {item['text']}
                </div>
                """, unsafe_allow_html=True)
            else:
                st.markdown(f"""
                <div style='background-color: #f3e5f5; padding: 10px; border-radius: 10px; margin: 5px 0; border-left: 4px solid #9c27b0;'>
                    <strong>üë§ {item['speaker']} [{item['timestamp']}]:</strong><br>
                    {item['text']}
                </div>
                """, unsafe_allow_html=True)
        
        # Protocolo de atenci√≥n
        st.subheader("üìã Evaluaci√≥n de Protocolo")
        protocol_labels = {
            'saludo_inicial': 'Saludo inicial',
            'identificacion': 'Solicitud de identificaci√≥n',
            'pregunta_ayuda': 'Pregunta de ayuda',
            'despedida': 'Despedida profesional'
        }
        
        for key, value in analysis['protocol_analysis'].items():
            label = protocol_labels.get(key, key)
            status = '‚úÖ CUMPLIDO' if value else '‚ùå NO CUMPLIDO'
            st.write(f"**{label}:** {status}")
        
        # Prompt para IA
        st.subheader("ü§ñ Prompt para Inteligencia Artificial")
        ai_prompt = generate_ai_prompt(dialogue, analysis, transcription)
        
        # Mostrar prompt en √°rea de texto copiable
        st.text_area(
            "Copia este texto completo y p√©galo en ChatGPT, Claude, o cualquier IA:",
            value=ai_prompt,
            height=400,
            help="Selecciona todo el texto (Ctrl+A) y c√≥pialo (Ctrl+C) para usar en tu IA favorita"
        )
        
        # Bot√≥n para limpiar
        if st.button("üóëÔ∏è Limpiar Resultados"):
            del st.session_state['transcription_result']
            if 'audio_file' in st.session_state:
                del st.session_state['audio_file']
            st.rerun()
    
    else:
        st.info("üëÜ Sube un archivo de audio en la primera pesta√±a o ingresa texto manualmente en la segunda pesta√±a para ver los resultados aqu√≠.")

# Footer
st.markdown("---")
st.markdown("*Sistema de An√°lisis de Performance para Call Center | Optimizado para Python 3.13*")
